open StdLabels
open Printf

module Param = struct
  type t =
    | Dirfd
    | Path
    | Flags of string
    | Int
    | Perm

  let c_type = function
    | Dirfd -> "int"
    | Path -> "char*"
    | Flags _ -> "int"
    | Int -> "int"
    | Perm -> "int"
  ;;

  let ml_type = function
    | Dirfd -> "Fd.t"
    | Path -> "string"
    | Flags s -> String.capitalize_ascii s ^ ".t list"
    | Int -> "int"
    | Perm -> "File_perm.t"
  ;;

  let of_val t var =
    match t with
    | Dirfd | Int | Perm -> sprintf "Int_val(%s)" var
    | Flags s -> sprintf "caml_convert_flag_list(%s, shexp_%s_table)" var s
    | Path -> sprintf "caml_stat_strdup(String_val(%s))" var
  ;;
end

module Result = struct
  type t =
    | Unit
    | Fd
end

type stub = string * (string * Param.t) list * Result.t * bool (* available on OSX *)

let stubs : stub list =
  let open Param in
  let dir = "dir", Dirfd in
  let olddir = "olddir", Dirfd in
  let newdir = "newdir", Dirfd in
  let path = "path", Path in
  let oldpath = "oldpath", Path in
  let newpath = "newpath", Path in
  let at_flags = "flags", Flags "at_flag" in
  let perm = "perm", Perm in
  [ "openat", [ dir; path; "flags", Flags "open_flag"; perm ], Fd, true
  ; "faccessat", [ dir; path; "mode", Flags "access_permission"; at_flags ], Unit, true
  ; "fchmodat", [ dir; path; perm; at_flags ], Unit, true
  ; "fchownat", [ dir; path; "uid", Int; "gid", Int; at_flags ], Unit, true
  ; "mkdirat", [ dir; path; perm ], Unit, true
  ; "unlinkat", [ dir; path; at_flags ], Unit, true
  ; "mkfifoat", [ dir; path; perm ], Unit, false
  ; "linkat", [ olddir; oldpath; newdir; newpath; at_flags ], Unit, true
  ; "renameat", [ olddir; oldpath; newdir; newpath ], Unit, true
  ; ( "renameat2"
    , [ olddir; oldpath; newdir; newpath; "flags", Flags "rename_flag" ]
    , Unit
    , true )
  ; "symlinkat", [ oldpath; newdir; newpath ], Unit, true
  ]
;;

let pr fmt = printf (fmt ^^ "\n")

let gen_stub ((name, params, result, on_osx) : stub) =
  let args ~prefix =
    List.map params ~f:(fun (v, _) -> prefix ^ v) |> String.concat ~sep:", "
  in
  pr "";
  if not on_osx
  then (
    pr "#if defined(__APPLE__)";
    pr "";
    pr "NA(%s)" name;
    pr "";
    pr "#else";
    pr "");
  pr "CAMLprim value shexp_has_%s() { return Val_true; }" name;
  pr "";
  pr "CAMLprim value shexp_%s(%s)" name (args ~prefix:"value v_");
  pr "{";
  pr "  CAMLparam%d(%s);" (List.length params) (args ~prefix:"v_");
  List.iter params ~f:(fun (v, t) -> pr "  %s %s;" (Param.c_type t) v);
  let result_var =
    match result with
    | Unit -> "res"
    | Fd -> "fd"
  in
  pr "  int %s;" result_var;
  pr "";
  List.iter params ~f:(fun (v, t) ->
    if t = Param.Path then pr "  caml_unix_check_path(v_%s, %S);" v name);
  let longest_arg =
    List.fold_left params ~init:0 ~f:(fun acc (v, _) -> max (String.length v) acc)
  in
  List.iter params ~f:(fun (v, t) ->
    pr "  %-*s = %s;" longest_arg v (Param.of_val t ("v_" ^ v)));
  pr "";
  pr "  caml_enter_blocking_section();";
  pr "  %s = %s(%s);" result_var name (args ~prefix:"");
  pr "  caml_leave_blocking_section();";
  pr "";
  List.iter params ~f:(fun (v, t) -> if t = Param.Path then pr "  caml_stat_free(%s);" v);
  let arg_for_errors =
    List.fold_left params ~init:"Nothing" ~f:(fun acc (v, t) ->
      if t = Param.Path then "v_" ^ v else acc)
  in
  pr "  if (%s == -1) uerror(%S, %s);" result_var name arg_for_errors;
  pr
    "  CAMLreturn(%s);"
    (match result with
     | Unit -> "Val_unit"
     | Fd -> "Val_int(fd)");
  pr "}";
  if not on_osx
  then (
    pr "";
    pr "#endif")
;;

let gen_external ((name, params, result, _on_osx) : stub) =
  pr "";
  pr "external %s" name;
  match params with
  | [] -> assert false
  | (v, t) :: rest ->
    pr "  :  %s:%s" v (Param.ml_type t);
    List.iter rest ~f:(fun (v, t) -> pr "  -> %s:%s" v (Param.ml_type t));
    pr
      "  -> %s"
      (match result with
       | Unit -> "unit"
       | Fd -> "Fd.t");
    pr "  @@ portable";
    pr "  = \"shexp_%s\"" name
;;

let gen_has_external ((name, _, _, _) : stub) =
  pr "";
  pr "external has_%s : unit -> bool = \"shexp_has_%s\"" name name;
  pr "";
  pr "let has_%s = has_%s ()" name name
;;

let () =
  let argv = Array.to_list Sys.argv in
  let comment = sprintf "This file was generated by: %s" (String.concat ~sep:" " argv) in
  match argv with
  | [ _; "c" ] ->
    pr "/* %s */" comment;
    pr "";
    pr "#include \"common.h\"";
    pr "";
    pr "#if defined(_WIN32)";
    pr "";
    List.iter stubs ~f:(fun (name, _, _, _on_osx) -> pr "NA(%s);" name);
    pr "";
    pr "#else /* defined(_WIN32) */";
    List.iter stubs ~f:gen_stub;
    pr "";
    pr "#endif /* defined(_WIN32) */"
  | [ _; "ml" ] ->
    pr "(* %s *)" comment;
    pr "";
    pr "open Types";
    List.iter stubs ~f:gen_external;
    List.iter stubs ~f:gen_has_external
  | _ ->
    eprintf "Usage: %s [c|ml]\n" Sys.argv.(0);
    exit 2
;;
